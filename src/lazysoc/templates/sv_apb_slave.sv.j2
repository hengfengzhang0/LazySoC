// {{ block.name }} APB4 Slave Register Module
// Auto-generated by LazySOC - DO NOT EDIT
//
// Address Map:
{% for reg in block.registers %}
//   {{ "0x%04X" | format(reg.offset) }} : {{ reg.name }} ({{ reg.access }})
{% endfor %}

module {{ block.name | lower }}_apb_slave (
    // Clock and Reset
    input  logic        pclk,
    input  logic        presetn,

    // APB4 Slave Interface
    input  logic [31:0] paddr,
    input  logic        psel,
    input  logic        penable,
    input  logic        pwrite,
    input  logic [31:0] pwdata,
    input  logic [3:0]  pstrb,
    input  logic [2:0]  pprot,

    output logic        pready,
    output logic [31:0] prdata,
    output logic        pslverr
);

  // ---------------------------------------------------------------------------
  // Local Parameters - Register Offsets
  // ---------------------------------------------------------------------------
{% for reg in block.registers %}
  localparam logic [31:0] OFFSET_{{ reg.name }} = 32'h{{ "%08X" | format(reg.offset) }};
{% endfor %}

  // ---------------------------------------------------------------------------
  // Register Declarations
  // ---------------------------------------------------------------------------
{% for reg in block.registers %}
{% if reg.access == "RW" %}
  logic [31:0] reg_{{ reg.name | lower }};
{% endif %}
{% endfor %}

  // ---------------------------------------------------------------------------
  // Internal Signals
  // ---------------------------------------------------------------------------
  logic [31:0] addr_offset;
  logic        wr_en;
  logic        rd_en;
  logic        decode_error;
  logic        write_to_ro_error;
  logic [31:0] next_prdata;
  logic        next_pslverr;

  // Address offset within the block (mask to relevant bits)
  assign addr_offset = paddr & 32'h0000FFFF;

  // Write enable: psel && penable && pwrite (Access Phase)
  assign wr_en = psel & penable & pwrite;

  // Read enable: psel && !pwrite (Setup Phase, data prepared for Access Phase)
  assign rd_en = psel & ~pwrite;

  // ---------------------------------------------------------------------------
  // Address Decode Logic (Combinational)
  // ---------------------------------------------------------------------------
  always_comb begin : addr_decode
    decode_error = 1'b0;
    write_to_ro_error = 1'b0;

    if (psel) begin
      case (addr_offset)
{% for reg in block.registers %}
        OFFSET_{{ reg.name }}: begin
{% if reg.access == "RO" %}
          if (pwrite) begin
            write_to_ro_error = 1'b1;
          end
{% endif %}
        end
{% endfor %}
        default: begin
          decode_error = 1'b1;
        end
      endcase
    end
  end

  // ---------------------------------------------------------------------------
  // Write Logic (Sequential)
  // ---------------------------------------------------------------------------
  always_ff @(posedge pclk or negedge presetn) begin : write_proc
    if (!presetn) begin
{% for reg in block.registers %}
{% if reg.access == "RW" %}
      reg_{{ reg.name | lower }} <= 32'h0;
{% endif %}
{% endfor %}
    end else if (wr_en && !decode_error && !write_to_ro_error) begin
      case (addr_offset)
{% for reg in block.registers %}
{% if reg.access == "RW" %}
        OFFSET_{{ reg.name }}: begin
          // Byte-enable write
          if (pstrb[0]) reg_{{ reg.name | lower }}[7:0]   <= pwdata[7:0];
          if (pstrb[1]) reg_{{ reg.name | lower }}[15:8]  <= pwdata[15:8];
          if (pstrb[2]) reg_{{ reg.name | lower }}[23:16] <= pwdata[23:16];
          if (pstrb[3]) reg_{{ reg.name | lower }}[31:24] <= pwdata[31:24];
        end
{% endif %}
{% endfor %}
        default: ; // No action
      endcase
    end
  end

  // ---------------------------------------------------------------------------
  // Read Logic (Combinational - generates next_prdata)
  // ---------------------------------------------------------------------------
  always_comb begin : read_comb
    next_prdata = 32'h0;
    next_pslverr = 1'b0;

    if (psel && penable) begin
      // Error conditions
      if (decode_error || write_to_ro_error) begin
        next_pslverr = 1'b1;
        next_prdata = 32'h0;
      end else if (!pwrite) begin
        // Read operation
        case (addr_offset)
{% for reg in block.registers %}
{% if reg.access == "RW" %}
          OFFSET_{{ reg.name }}: next_prdata = reg_{{ reg.name | lower }};
{% elif reg.access == "RO" %}
          OFFSET_{{ reg.name }}: next_prdata = 32'h0; // TODO: Connect to hardware status
{% endif %}
{% endfor %}
          default: next_prdata = 32'h0;
        endcase
      end
    end
  end

  // ---------------------------------------------------------------------------
  // Registered Output (Sequential)
  // ---------------------------------------------------------------------------
  always_ff @(posedge pclk or negedge presetn) begin : output_reg
    if (!presetn) begin
      prdata  <= 32'h0;
      pslverr <= 1'b0;
    end else begin
      prdata  <= next_prdata;
      pslverr <= next_pslverr;
    end
  end

  // PREADY always high for simple APB slave (no wait states)
  assign pready = 1'b1;

  // ---------------------------------------------------------------------------
  // Unused signal
  // ---------------------------------------------------------------------------
  // pprot is not used in this simple implementation
  logic unused_pprot;
  assign unused_pprot = |pprot;

endmodule : {{ block.name | lower }}_apb_slave
